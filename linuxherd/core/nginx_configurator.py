# linuxherd/core/nginx_configurator.py
# Manages internal Nginx config files and controls the internal Nginx process.
# Includes point to bundled mime.types and fastcgi_params.
# Current time is Sunday, April 20, 2025 at 4:50:22 PM +04 (Gyumri, Shirak Province, Armenia).

import os
import tempfile
from pathlib import Path
import shutil
import time
import shlex # Used by system_utils, good to have if modifying here later

# Import necessary functions from other core modules
try:
    from .system_utils import run_root_helper_action
    from .site_manager import get_site_settings
    from .php_manager import (
        start_php_fpm,
        get_php_fpm_socket_path,
        detect_bundled_php_versions
        )
except ImportError as e:
     print(f"ERROR in nginx_configurator: Could not import from core modules - {e}")
     # Dummy functions
     def run_root_helper_action(*args, **kwargs): return False, "system_utils not imported"
     def get_site_settings(*args, **kwargs): return None
     def start_php_fpm(*args, **kwargs): return False
     def get_php_fpm_socket_path(*args, **kwargs): return "/tmp/dummy.sock"
     def detect_bundled_php_versions(): return ["8.3"]


# --- Configuration Paths ---
CONFIG_DIR = Path(os.environ.get('XDG_CONFIG_HOME', Path.home() / '.config')) / 'linuxherd'
BUNDLES_DIR = Path(os.environ.get('XDG_DATA_HOME', Path.home() / '.local/share')) / 'linuxherd' / 'bundles'

INTERNAL_NGINX_CONF_DIR = CONFIG_DIR / 'nginx'
INTERNAL_SITES_AVAILABLE = INTERNAL_NGINX_CONF_DIR / 'sites-available'
INTERNAL_SITES_ENABLED = INTERNAL_NGINX_CONF_DIR / 'sites-enabled'
INTERNAL_LOG_DIR = CONFIG_DIR / 'logs'
INTERNAL_RUN_DIR = CONFIG_DIR / 'run'
INTERNAL_NGINX_CONF_FILE = INTERNAL_NGINX_CONF_DIR / 'nginx.conf'
INTERNAL_NGINX_PID_FILE = Path("/tmp/linuxherd-nginx.pid") # Using /tmp for PID
INTERNAL_NGINX_ERROR_LOG = INTERNAL_LOG_DIR / 'nginx-error.log'
INTERNAL_NGINX_ACCESS_LOG = INTERNAL_LOG_DIR / 'nginx-access.log'

# Paths within the bundle
NGINX_BINARY = BUNDLES_DIR / 'nginx/sbin/nginx'
BUNDLED_NGINX_CONF_DIR = BUNDLES_DIR / 'nginx/conf' # Location for bundled mime.types etc.

DEFAULT_PHP_SOCKET = CONFIG_DIR / 'run/php-fpm.sock' # Default if needed
SITE_TLD = "test"
DEFAULT_PHP = "default"
# --- End Configuration ---

def ensure_internal_nginx_structure():
    """
    Ensures internal directories and default nginx.conf exist.
    nginx.conf includes bundled mime.types. PID points to /tmp.
    """
    dirs_to_create = [
        INTERNAL_NGINX_CONF_DIR, INTERNAL_SITES_AVAILABLE,
        INTERNAL_SITES_ENABLED, INTERNAL_LOG_DIR, INTERNAL_RUN_DIR
    ]
    try:
        for dir_path in dirs_to_create:
            dir_path.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        print(f"FATAL: Could not create internal config directories: {e}")
        return False

    # Check if essential bundled config files exist
    bundled_mime_types = BUNDLED_NGINX_CONF_DIR / 'mime.types'
    bundled_fastcgi_params = BUNDLED_NGINX_CONF_DIR / 'fastcgi_params'
    if not bundled_mime_types.is_file():
        print(f"FATAL: Bundled mime.types not found at {bundled_mime_types}")
        return False
    # Note: fastcgi_params isn't included directly in nginx.conf but in site configs
    if not bundled_fastcgi_params.is_file():
         print(f"FATAL: Bundled fastcgi_params not found at {bundled_fastcgi_params}")
         return False


    if not INTERNAL_NGINX_CONF_FILE.is_file():
        print(f"Creating default internal nginx config at {INTERNAL_NGINX_CONF_FILE}")
        try:
            nginx_user = os.getlogin()
            nginx_pid_path_str = str(INTERNAL_NGINX_PID_FILE)
            # Use absolute paths for includes for clarity
            mime_types_path_str = str(bundled_mime_types.resolve())
            sites_enabled_path_str = str(INTERNAL_SITES_ENABLED.resolve())

            default_config = f"""# Default nginx.conf generated by LinuxHerd Helper
# user {nginx_user}; # Master runs as root, workers often as non-root
worker_processes auto;
pid "{nginx_pid_path_str}";
error_log "{INTERNAL_NGINX_ERROR_LOG}" warn;

events {{ worker_connections 768; }}

http {{
    # Include BUNDLED mime.types <<< MODIFIED
    include       "{mime_types_path_str}";
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log "{INTERNAL_NGINX_ACCESS_LOG}" main;
    sendfile        on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    # Include site configurations from internal sites-enabled directory
    include "{sites_enabled_path_str}/*.conf";
}}
"""
            with open(INTERNAL_NGINX_CONF_FILE, 'w', encoding='utf-8') as f:
                f.write(default_config)
        except (OSError, IOError) as e:
            print(f"FATAL: Could not write default internal nginx config: {e}")
            return False
    return True

def generate_site_config(site_path_str, site_name, server_name, php_socket_path):
    """
    Generates Nginx server block config string using bundled fastcgi_params.
    """
    site_path = Path(site_path_str)
    if not site_path.is_dir(): return ""
    public_root = site_path / 'public'; root_path = public_root if public_root.is_dir() else site_path
    root_path_str = str(root_path.resolve()).replace('\\', '\\\\').replace('"', '\\"')
    access_log_path = INTERNAL_LOG_DIR / f"{site_name}.access.log"
    error_log_path = INTERNAL_LOG_DIR / f"{site_name}.error.log"
    php_socket_path_str = str(Path(php_socket_path).resolve())
    # Use absolute path for bundled fastcgi_params <<< MODIFIED
    bundled_fastcgi_params_path = str((BUNDLED_NGINX_CONF_DIR / 'fastcgi_params').resolve())

    config = f"""# Configuration for {server_name} generated by LinuxHerd Helper
server {{
    listen 80; listen [::]:80; server_name {server_name}; root "{root_path_str}";
    index index.php index.html index.htm;
    access_log "{access_log_path}"; error_log "{error_log_path}" warn; charset utf-8;
    location / {{ try_files $uri $uri/ /index.php?$query_string; }}
    location ~ /\. {{ deny all; }}
    location ~ \.php$ {{
        try_files $uri =404; fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:{php_socket_path_str}; fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        # Include BUNDLED fastcgi_params <<< MODIFIED
        include "{bundled_fastcgi_params_path}";
    }} }}"""
    return config


# --- Nginx Process Control Functions ---
# (start_internal_nginx, stop_internal_nginx, reload_internal_nginx unchanged)
def start_internal_nginx():
    print("Attempting to start internal Nginx...")
    if not ensure_internal_nginx_structure(): return False, "Failed config structure check."
    if not NGINX_BINARY.is_file(): return False, f"Nginx binary not found: {NGINX_BINARY}"
    success, message = run_root_helper_action(action="start_internal_nginx", nginx_binary_path=str(NGINX_BINARY.resolve()), nginx_config_path=str(INTERNAL_NGINX_CONF_FILE.resolve()), nginx_pid_path=str(INTERNAL_NGINX_PID_FILE.resolve()))
    if success: print("Start internal Nginx action reported success."); time.sleep(0.5)
    else: print(f"Start internal Nginx action failed: {message}")
    return success, message

def stop_internal_nginx():
    print("Attempting to stop internal Nginx...")
    success, message = run_root_helper_action(action="stop_internal_nginx", nginx_pid_path=str(INTERNAL_NGINX_PID_FILE.resolve()))
    if success: print("Stop internal Nginx action reported success.")
    else: print(f"Stop internal Nginx action failed: {message}")
    return success, message

def reload_internal_nginx():
    print("Attempting to reload internal Nginx configuration...")
    success, message = run_root_helper_action(action="reload_internal_nginx", nginx_pid_path=str(INTERNAL_NGINX_PID_FILE.resolve()))
    if success: print("Reload internal Nginx action reported success.")
    else: print(f"Reload internal Nginx action failed: {message}")
    return success, message


# --- Site Configuration Functions ---
def install_nginx_site(site_path_str):
    """Installs internal Nginx site config and reloads."""
    # (Implementation unchanged from version that added PHP checks)
    print(f"Configuring internal Nginx site for: {site_path_str}")
    if not ensure_internal_nginx_structure(): return False, "Internal structure check failed"
    site_path = Path(site_path_str)
    if not site_path.is_dir(): msg = f"Site path '{site_path_str}' not dir."; print(f"Configurator Error: {msg}"); return False, msg
    site_name = site_path.name; server_name = f"{site_name}.{SITE_TLD}"; config_filename = f"{site_name}.conf"
    available_path = INTERNAL_SITES_AVAILABLE / config_filename; enabled_path = INTERNAL_SITES_ENABLED / config_filename
    site_settings = get_site_settings(site_path_str)
    if not site_settings: msg = f"Could not load settings for site '{site_path_str}'."; print(f"Configurator Error: {msg}"); return False, msg
    php_version_setting = site_settings.get("php_version", DEFAULT_PHP)
    if php_version_setting == DEFAULT_PHP:
        available_versions = detect_bundled_php_versions();
        if not available_versions: msg = "No bundled PHP found for default."; print(f"Configurator Error: {msg}"); return False, msg
        php_version_to_use = available_versions[0]
        print(f"Site uses default PHP, resolved to: {php_version_to_use}")
    else: php_version_to_use = php_version_setting; print(f"Site configured for PHP version: {php_version_to_use}")
    php_socket_path = get_php_fpm_socket_path(php_version_to_use)
    print(f"Ensuring PHP-FPM {php_version_to_use} is running...");
    if not start_php_fpm(php_version_to_use): msg = f"Failed start PHP-FPM {php_version_to_use}."; print(f"Configurator Error: {msg}"); return False, msg
    print(f"PHP-FPM {php_version_to_use} confirmed running (or start attempted).")
    config_content = generate_site_config(site_path_str, site_name, server_name, php_socket_path)
    if not config_content: msg = f"Failed Nginx config generation."; print(f"Configurator Error: {msg}"); return False, msg
    try: # Write config and symlink
        print(f"Writing config to {available_path}"); f=open(available_path,'w',encoding='utf-8'); f.write(config_content); f.close(); os.chmod(available_path, 0o644)
        link_created = False
        if enabled_path.exists():
            if not enabled_path.is_symlink() or os.readlink(enabled_path) != str(available_path): enabled_path.unlink(); os.symlink(available_path, enabled_path); link_created = True
        else: os.symlink(available_path, enabled_path); link_created = True
        if link_created: print(f"Symlink created/verified: {enabled_path}")
        else: print(f"Symlink already exists correctly: {enabled_path}")
    except Exception as e: msg = f"File op failed: {e}"; print(f"Configurator Error: {msg}"); return False, msg
    print("Triggering internal Nginx reload..."); success_reload, msg_reload = reload_internal_nginx()
    if not success_reload: msg = f"Site configured but reload failed: {msg_reload}"; print(f"Configurator Warning: {msg}"); return True, msg # Warn
    else: msg = f"Site {site_name} (PHP {php_version_to_use}) configured; Nginx reloaded."; print(msg); return True, msg

def uninstall_nginx_site(site_path_str):
    """Removes internal Nginx site config/symlink and reloads."""
    # (Implementation unchanged from previous version)
    print(f"Removing internal Nginx site config for: {site_path_str}")
    if not ensure_internal_nginx_structure(): return False, "Internal structure check failed"
    site_path = Path(site_path_str); site_name = site_path.name
    config_filename = f"{site_name}.conf"; available_path = INTERNAL_SITES_AVAILABLE / config_filename
    enabled_path = INTERNAL_SITES_ENABLED / config_filename; errors_occurred = False; files_changed = False
    try: # Remove symlink
        if enabled_path.is_symlink(): enabled_path.unlink(); files_changed = True; print("Removed symlink.")
        elif enabled_path.exists(): print(f"Item '{enabled_path}' not symlink.")
        else: print(f"Symlink '{enabled_path}' not found.")
    except OSError as e: errors_occurred = True; print(f"Configurator Error removing symlink: {e}")
    try: # Remove config file
        if available_path.is_file(): available_path.unlink(); files_changed = True; print("Removed config file.")
        elif available_path.exists(): print(f"Item '{available_path}' not file.")
        else: print(f"Config file '{available_path}' not found.")
    except OSError as e: errors_occurred = True; print(f"Configurator Error removing file: {e}")
    if errors_occurred: return False, f"Errors occurred during file removal for '{site_name}'."
    if files_changed:
        print("Config files removed. Triggering internal Nginx reload...")
        success_reload, msg_reload = reload_internal_nginx() # Calls helper via pkexec
        if not success_reload: return True, f"Files removed, but Nginx reload failed: {msg_reload}" # Warn
        else: return True, f"Site {site_name} config removed and Nginx reloaded."
    else: return True, f"Nginx config for {site_name} already absent."


# --- Example Usage ---
if __name__ == "__main__":
    print("--- Testing Nginx Config Generation Only ---")
    # Ensure base structure exists for test run
    if ensure_internal_nginx_structure():
        test_path_str = str(Path.home() / "Projects" / "test-site-internal-gen")
        test_site_path_str = str(Path.home() / "Projects" / "test-site-internal-gen")
        test_public_path = Path(test_path_str) / "public"
        test_public_path.mkdir(parents=True, exist_ok=True)
        site_name = Path(test_path_str).name; server_name = f"{site_name}.{SITE_TLD}"
        socket_path_example = str(CONFIG_DIR / 'run/php8.3-fpm.sock') # Example socket
        config = generate_site_config(test_site_path_str, site_name, server_name, socket_path_example)
        print(f"\nGenerated config using socket {socket_path_example} for: {test_path_str}")
        print("-" * 20); print(config); print("-" * 20)
    else:
        print("\nCould not ensure internal structure for testing.")